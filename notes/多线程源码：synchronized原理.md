## 多线程源码：synchronized原理

### 1、synchronized简介

synchronized是Java的一个关键字，是一种互斥锁。来自官方的解释：Synchronized方法支持一种简单的策略，用于防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读或写操作都通过Synchronized方法完成。

**Synchronized是最基本的互斥手段**，保证同一时刻最多只有1个线程执行被Synchronized修饰的方法 / 代码，其他线程 必须等待当前线程执行完该方法 / 代码块后才能执行该方法 / 代码块。

在JDK1.5之前synchronized是一个重量级锁，相对于j.u.c.Lock，它会显得那么笨重，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。

* **什么是锁？**

  锁的本质就是一个对象，当多个线程争抢同个锁的时，同一时间内只会有一个线程获取锁，只有获取锁的线程才能执行锁内的代码，其他线程执行到锁代码时会进入阻塞状态，等待锁释放后进行争抢。synchronized就是一种常见的锁。

  是异步还是同步主要就是看synchronized是不是同一把锁。

  如果是同一把锁，那么就是同步执行

  如果不是同一把锁，那么就是异步执行

* **作用，特性**

  Synchronized保证同一时刻有且只有一条线程在操作共享数据，其他线程必须等待该线程处理完数据后再对共享数据进行操作。此时便产生了互斥锁，互斥锁的特性如下：

  **原子性(互斥性)：**多个操作作为一个整体，不能被分割与中断，也不能被其他线程干扰。如果被中断与干扰，则会出现数据异常、逻辑异常。在同一时刻只允许一个线程持有某个对象锁，通过这种特性来实现多线程协调机制，这样在同一时刻只有一个线程对所需要的同步的代码块（复合操作）进行访问。互斥性也成为了操作的原子性。

  **可见性：**一个线程修改的共享变量，其他线程是否能够立刻看到。对于串行程序而言，并不存在可见性问题，前一个操作修改的变量，后一个操作一定能读取到最新值。但在多线程环境下如果没有正确的同步则不一定。

  **synchronized有序性：**多线程之间串行执行。volatile有序性和synchronized有序性不同

* **volatile的有序性和synchronized不同**

  > 怎么来定义顺序呢?《深入理解Java虚拟机第三版》有提到
  > Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内似表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。
  >
  > 「synchronized」 的有序性是持有相同锁的两个同步块只能串行的进入，即被加锁的内容要按照顺序被多个线程执行，但是其内部的同步代码还是会发生重排序，使块与块之间有序可见。
  > 「volatile」的有序性是通过插入内存屏障来保证指令按照顺序执行。不会存在后面的指令跑到前面的指令之前来执行。是保证编译器优化的时候不会让指令乱序。
  > 「synchronized 是不能保证指令重排的」。
  > synchronized可以保证原子性和可见性
  > ————————————————
  > 版权声明：本文为CSDN博主「小白划水」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
  > 原文链接：https://blog.csdn.net/qq_42218187/article/details/118558526

  synchronized的有序性是指多个线程之间的synchronized块或方法时串行的。

  volatile的有序性是通过内存屏障实现，通过加Lock前缀的方式禁止指令重排。它能保证代码不会在编译时被jit优化重排序，也能保证被修饰的变量内部的多个操作不会被重排序。DCL单例模式中用了synchronized修饰，但是在new Singleton()时还是会出现问题，因为创建对象在CPU层面分为3步（和缓存无关），创建对象分配内存空间、初始化对象、将对象指向分配的内存空间，这3步会被重排序，所以要加volatile禁止指令重排。

  **总结，synchronized可以保证有序性但是不能避免指令重排。严格来说，有序性和指令重排之间存在一些细微的区别，禁止指令重排不仅包含了CPU层面的缓存同步操作，还包含了编译和运行期间的操作指令有序。**

  *如果你看过另一篇文章：《volatile底层原理(CPU多级缓存)》，对于这一点应该就能更好的理解了*

* **使用**

  - 修饰实例方法：作用于当前实例加锁
  - 修饰静态方法：作用于当前类加锁
  - 修饰代码块：指定加锁对象，对给定对象加锁

  作用范围不同，粒度不同，用于不同的场景。

* **线程安全问题**

  变量在多线程情况下会出现安全性问题，安全性问题指的是多个线程同时访问同一个变量时，会发生混乱，如果都改变了变量的值，可能与最终想要的结果不同。

  触发线程安全问题的前置条件是：多线程，有**共享变量**，有线程安全性问题（实例变量），**局部变量**没有线程安全性问题。

  共享变量：不安全

  局部变量：安全

  ```java
  public class Sync1 {
  
      private int num = 0;
  
      public static void main(String[] args) {
          final Sync1 sync1 = new Sync1();
          new Thread(() -> {
              sync1.addNum(1);
          }, "thread1").start();
  
          new Thread(() -> {
              sync1.addNum(2);
          }, "thread2").start();
      }
  
      public void addNum(int i) {
          if (i == 1) {
              num = 100;
          } else {
              num = 200;
          }
          /**
           * 正常情况：
           * current thread->thread1,i->1,num->100
           * current thread->thread2,i->2,num->200
           * 异常情况：
           * current thread->thread1,i->1,num->100
           * current thread->thread2,i->2,num->100
           * <p> 
           * current thread->thread1,i->1,num->200
           * current thread->thread2,i->2,num->200
           */
          System.out.println("current thread->" + Thread.currentThread().getName() + ",i->" + i + ",num->" + num);
      }
  }
  ```

  以上代码中的num变量就是不安全的，两个线程同时操作时，会出现安全性问题。

  原因其实很简单，就是因为num还没被读取，就又被再次重新赋值了。

  上述代码中每一个线程都执行了两个指令：

  线程1： 1、num=100；2、read num打印。

  线程2： 3、num=200；4、read num打印。

  当指令顺序为 1 2 3 4，结果就是正常情况

  但是因为是多线程，所以指令是会交替进行的

  当指令顺序为 1 3 4 2，结果是num都为200

  当指令顺序为 3 1 2 4，结果是num都为100

  

  **上述情况中属于有序性问题，但是无法使用volatile解决，因为volatile只能保证对num的读写不会重排序，也就是说只能保证1、2不被重排序，3、4不被重排序，无法保证1、2之间不会被插入3。**并且1、2之间是有关联的，本身就不会被重排序，所以这里加volatile是没有任何作用的。

  可以使用synchronized修饰addNum方法，当进入一个synchronized获取了锁之后，另一个线程再次获取时就必须等待解锁，锁里的代码是串行化的，所以可以解决上述问题。



### 2、synchronized实现原理

Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成。线程访问加锁对象，就是去拥有一个监视器（Monitor）的过程。

　　每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时就会处于锁定状态并且尝试获取monitor的所有权 ，过程：

　　1）如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；

　　2）如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1（可重入）；

　　3）如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

* **字节码解析**

  * **同步方法**

    方法级的同步是隐式的，无须通过字节码指令来控制，JVM可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。

    当方法调用的时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置。如果设置了，执行线程就要求先持有monitor对象，然后才能执行方法，最后当方法执行完（无论是正常完成还是非正常完成）时释放monitor对象。

    在方法执行期间，执行线程持有了管程，其他线程都无法再次获取同一个管程。

    *管程是一种概念，任何语言都可以通用。在java中，管程==Monitor*

  * **同步代码块**

    同步代码块，synchronized关键字经过编译之后，会在同步代码块前后分别形成monitorenter和monitorexit字节码指令。在执行monitorenter指令的时候，首先尝试获取对象的锁。

    如果这个锁没有被锁定或者当前线程已经拥有了那个对象的锁，锁的计数器就加1。在执行monitorexit指令时会将锁的计数器减1，当减为0的时候就释放锁。如果获取对象锁一直失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。

* **Monitor**

  

* **锁重入**

  synchronized是可重入锁，进入一个A锁的代码块或方法之后，又在代码块内遇到A锁，还可以继续进入A锁。每次进入A锁都会将monitorenter+1，每次释放A锁会将monitorexit-1，当monitorCount==0时，代表当前线程完全退出锁，其他线程可开始争抢锁。

  重入锁一定要注意，在锁嵌套的时候，所有嵌套的方法签名上一定要加synchronized关键字，否则其他线程在调用无synchronized关键字的方法时就无需争抢锁。

  * 继承时锁重入

    在继承关系下锁重入机制也是可行的，可以直接调用，不需要等待，这就是synchronized 父子类锁重入 。因为子类继承了父类实际上就是拥有了父类的public方法，所有父类的public 方法也属于子类对象。同一个对象拥有了同一把锁，不需要竞争。

* **synchronized修饰的方法如果发生异常锁怎么办？会释放吗？**

  发生异常后会释放锁。假设两个方法都是有synchronized修饰的，其中一个发生异常了，jvm会在发生异常之后自动释放锁，让另一个方法获取锁并执行。在JVM底层中当线程在获取锁的状态下发生了异常，jvm会自动调用monitorExit来释放锁。

