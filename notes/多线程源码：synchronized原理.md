## 多线程源码：synchronized原理

### 1、synchronized

#### （1）简介

synchronized是Java的一个关键字，是一种互斥锁。来自官方的解释：Synchronized方法支持一种简单的策略，用于防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读或写操作都通过Synchronized方法完成。

**Synchronized是最基本的互斥手段**，保证同一时刻最多只有1个线程执行被Synchronized修饰的方法 / 代码，其他线程 必须等待当前线程执行完该方法 / 代码块后才能执行该方法 / 代码块。

* **特性**

  Synchronized保证同一时刻有且只有一条线程在操作共享数据，其他线程必须等待该线程处理完数据后再对共享数据进行操作。此时便产生了互斥锁，互斥锁的特性如下：

  **原子性(互斥性)：**多个操作作为一个整体，不能被分割与中断，也不能被其他线程干扰。如果被中断与干扰，则会出现数据异常、逻辑异常。在同一时刻只允许一个线程持有某个对象锁，通过这种特性来实现多线程协调机制，这样在同一时刻只有一个线程对所需要的同步的代码块（复合操作）进行访问。互斥性也成为了操作的原子性。

  **可见性：**一个线程修改的共享变量，其他线程是否能够立刻看到。对于串行程序而言，并不存在可见性问题，前一个操作修改的变量，后一个操作一定能读取到最新值。但在多线程环境下如果没有正确的同步则不一定。

  **有序性：**代码最终执行的顺序与我们看到的代码的顺序一致。串行执行。多线程下可能会发生指令重排，后面的操作反而先执行。



#### （2）线程安全问题

变量在多线程情况下会出现安全性问题，安全性问题指的是多个线程同时访问同一个变量时，会发生混乱，如果都改变了变量的值，可能与最终想要的结果不同。

触发线程安全问题的前置条件是：多线程，有**共享变量**，有线程安全性问题（实例变量），**局部变量**没有线程安全性问题。

共享变量：不安全

局部变量：安全

```java
public class Sync1 {

    private int num = 0;

    public static void main(String[] args) {
        final Sync1 sync1 = new Sync1();
        new Thread(() -> {
            sync1.addNum(1);
        }, "thread1").start();

        new Thread(() -> {
            sync1.addNum(2);
        }, "thread2").start();
    }

    public void addNum(int i) {
        if (i == 1) {
            num = 100;
        } else {
            num = 200;
        }
        /**
         * 正常情况：
         * current thread->thread1,i->1,num->100
         * current thread->thread2,i->2,num->200
         * 异常情况：
         * current thread->thread1,i->1,num->100
         * current thread->thread2,i->2,num->100
         * <p> 
         * current thread->thread1,i->1,num->200
         * current thread->thread2,i->2,num->200
         */
        System.out.println("current thread->" + Thread.currentThread().getName() + ",i->" + i + ",num->" + num);
    }
}
```

以上代码中的num变量就是不安全的，两个线程同时操作时，会出现安全性问题。

原因其实很简单，就是因为num还没被读取，就又被再次重新赋值了。

上述代码中每一个线程都执行了两个指令：

线程1： 1、num=100；2、read num打印。

线程2： 3、num=200；4、read num打印。

当指令顺序为 1 2 3 4，结果就是正常情况

但是因为是多线程，所以指令是会交替进行的

当指令顺序为 1 3 4 2，结果是num都为200

当指令顺序为 3 1 2 4，结果是num都为100



**上述情况中属于有序性问题，但是无法使用volatile解决，因为volatile只能保证对num的读写不会重排序，也就是说只能保证1、2不被重排序，3、4不被重排序，无法保证1、2之间不会被插入3。**并且1、2之间是有关联的，本身就不会被重排序，所以这里加volatile是没有任何作用的。

