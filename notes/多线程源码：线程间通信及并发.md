## 多线程源码：线程间通信及并发

### 1、线程并发安全机制

java多线程有三大特性：原子性、可见性、有序性

**原子性：**多个操作作为一个整体，不能被分割与中断，也不能被其他线程干扰。如果被中断与干扰，则会出现数据异常、逻辑异常。

**可见性：**一个线程修改的共享变量，其他线程是否能够立刻看到。对于串行程序而言，并不存在可见性问题，前一个操作修改的变量，后一个操作一定能读取到最新值。但在多线程环境下如果没有正确的同步则不一定。

**有序性：**指从观察到的结果推测，代码最终执行的顺序与我们看到的代码的顺序不一致。

#### （1）volatile机制

volatile是Java提供的一种轻量级的同步机制，保证了多线程之间的可见性和有序性。在多个线程需要共享同一个变量时，此变量可用volatile关键字修饰，被修饰后的变量在修改之后所有读取它的线程都能获取到正确的值。

volatile的底层实现非常复杂，多数是硬件级别的操作。

* **可见性问题代码示例**

  假设有两个线程AB，还有一个类变量int i=0。启动线程后马上再A线程中执行i=1，过两秒再B线程中获取i，取到的值可能还是0。这就是一个典型的可见性问题。其实这就是可见性问题，我们只要在变量i上增加volatile关键字即可解决。

  我们先来看几段代码：

  ```java
  public class volatile1 {
  
      static int i = 0;
  
      public static void main(String[] args) {
  
          new Thread(() -> {
              while (true) {
                  if (i == 1) {
                      System.out.println(Thread.currentThread().getName() + ">>>>> i = " + i);
                      break;
                  }
              }
          }, "A").start();
  
          new Thread(() -> {
              try {
                  Thread.sleep(2000);
              } catch (InterruptedException e) {
                  throw new RuntimeException(e);
              }
              i = 1;
          }, "B").start();
          
      }
  }
  ```

  以上代码是一个常见的案例，对多线程有过一些了解的同学就能知道此时A线程中的打印是无法执行的，因为此处就存在可见性问题。这时由于每个线程对于i变量都有一个属于自己的副本，A线程获取副本时i=0，B线程修改了i的值之后A线程并没有去内存中重新获取i，没有人通知A去刷新副本，所以A里的打印不会执行。

  如果将A线程的休眠时间大于B线程，即在B修改了i的值之后，A再进入判断，则可以打印。因为B修改了值之后会将这个值写回内存，此时内存中的i已经是1了，那么当A获取内存中的i值作为副本时，自然i就等于1了。

* **可见性诡异问题**

  让我们保持上面代码的其他部分，只在A线程的循环内加入一段打印。代码如下：

  ```java
  ...
          new Thread(() -> {
              while (true) {
                  System.out.println("haha");
                  if (i == 1) {
                      System.out.println(Thread.currentThread().getName() + ">>>>> i = " + i);
                      break;
                  }
              }
          }, "A").start();
  ...
  ```

  按照我们上面的理解，此处应该还是无法打印i的值才对，但事实上却可以。这是为何呢？

  网络上有人总结了几种会出现可打印的情况：

  1. 加一行`System.out.println();`
  2. 加同步块`synchronized`
  3. 加`Thread.sleep()`休眠
  4. 加一行`File file = new File(filePath);`

  以上这几种情况都会让A线程拿到真正的i值，为什么呢？有人总结是有操作io，所以可以拿到，其实不是。

  真正的原因是这几种方法都用到了synchronized关键字，无论是打印还是线程的休眠又或是File的构造方法中，都一定有synchronized关键字出现，synchronized可以保证可见性、有序性、原子性。所以是代码遇到了synchronized的时候去刷新了副本，这时i才可以拿到最新的值。以上代码中的`System.out.println("haha");`就是通知线程去刷新副本的。

* **什么时候会自动刷新副本？**

  ```java
  public class Volatile2 {
  
      static int i = 0;
      private static final int count = 600; // 100 200 300 ... 10000 100000
  
      public static void main(String[] args) {
          new Thread(() -> {
              final List<Integer> list = new ArrayList<>();
              for (int j = 1; j <= count; j++) {
                  list.add(j);
              }
  
              while (true) {
                  if (list.contains(i)) {
                      System.out.println(Thread.currentThread().getName() + ">>>> i = " + i);
                      break;
                  }
              }
          }, "A").start();
  
          new Thread(() -> {
              try {
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  throw new RuntimeException(e);
              }
              for (int j = 1; j <= count; j++) {
                  i = j;
              }
          }, "B").start();
      }
  }
  ```

  以上代码中在A线程中首先创建出一个list并且往里面插入了1-n的数字，然后进入循环，判断list是否包含i。B线程中休眠1秒之后（为了确保A线程已经准备好list并进入循环），也开始循环给i赋值。当i达到一定值的时候，在A线程中的副本就会被刷新。在windows系统下大概是i=600的时候，A线程中打印的i值也是600。这貌似说明了当i到达600的时候就会让A线程刷新一次副本，但是我们加大数字到100000时会发现最终打印的i值不固定。可能是10W，也可能是几千。

  这个例子中就抛出了两个问题：

  1. 这个刷新副本的阈值是如何得出的，为什么到了这个值就会刷新副本？
  2. 为什么刷新副本的值是随机的，有时10W有时几千？

  这其实是由CPU多级缓存架构造成的，我们接着来详细讲解。
